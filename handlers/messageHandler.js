const OpenAI = require('openai');

class MessageHandler {
  constructor(revoltAPI, messageManager, shaperHandler, availableShapes, apiKey, botOwnerId) {
    this.api = revoltAPI;
    this.messageManager = messageManager;
    this.shaperHandler = shaperHandler;
    this.availableShapes = availableShapes;
    this.botOwnerId = botOwnerId;
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Shapes API –∫–ª–∏–µ–Ω—Ç–∞
    this.shapes = new OpenAI({
      apiKey: apiKey,
      baseURL: 'https://api.shapes.inc/v1',
    });
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
  async handleMessage(message, botId) {
    try {
      // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
      if (message.author === botId) return;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–º–∞–Ω–¥—É !shaper
      if (message.content && message.content.trim() === '!shaper') {
        await this.shaperHandler.handleShaperCommand(message.channel, message._id);
        return;
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–º–∞–Ω–¥—ã Shapes API
      if (message.content && message.content.trim().startsWith('!shape_')) {
        await this.handleShapeCommand(message, botId);
        return;
      }

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ
      const shouldRespond = await this.shouldRespondToMessage(message, botId);
      if (!shouldRespond) return;

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
      await this.processMessage(message, botId);
      
    } catch (error) {
      console.error('Error handling message:', error.message);
    }
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ Shapes API
  async handleShapeCommand(message, botId) {
    try {
      const content = message.content.trim();
      const commandMatch = content.match(/^!shape_(\w+)(?:\s+(.+))?$/);
      
      if (!commandMatch) {
        await this.sendHelpMessage(message.channel, message.author === this.botOwnerId);
        return;
      }

      const [, command, args] = commandMatch;
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –¥–µ—Å—Ç—Ä—É–∫—Ç–∏–≤–Ω—ã—Ö –∫–æ–º–∞–Ω–¥
      const ownerOnlyCommands = ['reset', 'wack', 'sleep', 'dashboard'];
      if (ownerOnlyCommands.includes(command) && message.author !== this.botOwnerId) {
        const masquerade = await this.shaperHandler.getActiveMasquerade(message.channel);
        await this.messageManager.sendMessage(
          message.channel, 
          "‚ùå **–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω!** –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª—å—Ü—É –±–æ—Ç–∞.", 
          masquerade
        );
        return;
      }

      // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã help
      if (command === 'help') {
        await this.sendHelpMessage(message.channel, message.author === this.botOwnerId);
        return;
      }

      // –§–æ—Ä–º–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—É –¥–ª—è Shapes API
      let shapeCommand;
      switch (command) {
        case 'imagine':
          shapeCommand = args ? `!imagine ${args}` : '!imagine a beautiful landscape';
          break;
        case 'web':
          shapeCommand = args ? `!web ${args}` : '!web latest news';
          break;
        case 'reset':
          shapeCommand = '!reset';
          break;
        case 'sleep':
          shapeCommand = '!sleep';
          break;
        case 'info':
          shapeCommand = '!info';
          break;
        case 'dashboard':
          shapeCommand = '!dashboard';
          break;
        case 'wack':
          shapeCommand = '!wack';
          break;
        default:
          await this.sendHelpMessage(message.channel, message.author === this.botOwnerId);
          return;
      }

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂
      const activeShapeId = this.shaperHandler.getActiveShape(message.channel);
      let shapeUsername;
      
      if (activeShapeId && this.availableShapes[activeShapeId]) {
        shapeUsername = this.availableShapes[activeShapeId];
      } else {
        const firstShapeId = Object.keys(this.availableShapes)[0];
        shapeUsername = this.availableShapes[firstShapeId];
      }

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –∫ Shapes API
      const response = await this.shapes.chat.completions.create({
        model: `shapesinc/${shapeUsername}`,
        messages: [{ role: "user", content: shapeCommand }],
        temperature: 0.7,
        max_tokens: 1000
      });

      const aiResponse = response.choices[0].message.content;
      const masquerade = await this.shaperHandler.getActiveMasquerade(message.channel);
      
      await this.messageManager.sendMessage(message.channel, aiResponse, masquerade);

    } catch (error) {
      console.error('Error handling shape command:', error.message);
      
      const masquerade = await this.shaperHandler.getActiveMasquerade(message.channel);
      await this.messageManager.sendMessage(
        message.channel, 
        "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–º–∞–Ω–¥—ã.", 
        masquerade
      );
    }
  }

  // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é –ø–æ –∫–æ–º–∞–Ω–¥–∞–º
  async sendHelpMessage(channelId, isOwner = false) {
    let helpText = `ü§ñ **–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã Shapes API:**

**–¢–≤–æ—Ä—á–µ—Å—Ç–≤–æ:**
‚Ä¢ \`!shape_imagine [–æ–ø–∏—Å–∞–Ω–∏–µ]\` - –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è

**–ü–æ–∏—Å–∫:**
‚Ä¢ \`!shape_web [–∑–∞–ø—Ä–æ—Å]\` - –ü–æ–∏—Å–∫ –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ

**–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:**
‚Ä¢ \`!shape_info\` - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ
‚Ä¢ \`!shape_help\` - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É`;

    if (isOwner) {
      helpText += `

**üîí –ö–æ–º–∞–Ω–¥—ã –≤–ª–∞–¥–µ–ª—å—Ü–∞:**
‚Ä¢ \`!shape_reset\` - –°–±—Ä–æ—Å –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–π –ø–∞–º—è—Ç–∏
‚Ä¢ \`!shape_wack\` - –°–±—Ä–æ—Å –∫—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω–æ–π –ø–∞–º—è—Ç–∏
‚Ä¢ \`!shape_sleep\` - –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏
‚Ä¢ \`!shape_dashboard\` - –°—Å—ã–ª–∫–∞ –Ω–∞ –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è`;
    } else {
      helpText += `

*–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∫–æ–º–∞–Ω–¥—ã –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª—å—Ü—É –±–æ—Ç–∞.*`;
    }

    helpText += `\n\n*–ö–æ–º–∞–Ω–¥—ã –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –æ—Ç –∏–º–µ–Ω–∏ —Ç–µ–∫—É—â–µ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞.*`;

    await this.messageManager.sendMessage(channelId, helpText);
  }

  // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ
  async shouldRespondToMessage(message, botId) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –±–æ—Ç–∞
    const isMentioned = message.content && message.content.includes(`<@${botId}>`);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –æ—Ç–≤–µ—Ç–æ–º –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –±–æ—Ç–∞
    const isReplyToBot = this.messageManager.isReplyToBot(message.replies);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –ª–∏—á–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
    let isDM = false;
    try {
      const { data: channelData } = await this.api.get(`/channels/${message.channel}`);
      isDM = channelData.channel_type === 'DirectMessage';
    } catch (err) {
      console.error('Error checking channel type:', err.message);
    }

    return isMentioned || isDM || isReplyToBot;
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞
  async processMessage(message, botId) {
    try {
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      this.messageManager.addRecentUserMessage(message._id, {
        content: message.content,
        attachments: message.attachments,
        channelId: message.channel,
        authorId: message.author,
        _id: message._id
      });

      // –û—á–∏—â–∞–µ–º —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∏–∑ —Ç–µ–∫—Å—Ç–∞
      let content = message.content || '';
      if (content.includes(`<@${botId}>`)) {
        content = content.replace(new RegExp(`<@${botId}>`, 'g'), '').trim();
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–ª–æ–∂–µ–Ω–∏—è
      const attachments = this.processAttachments(message.attachments);

      // –ï—Å–ª–∏ –Ω–µ—Ç —Ç–µ–∫—Å—Ç–∞ –∏ –≤–ª–æ–∂–µ–Ω–∏–π, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ
      if (!content && !attachments) {
        const masquerade = await this.shaperHandler.getActiveMasquerade(message.channel);
        await this.messageManager.sendMessage(
          message.channel, 
          "Hello! How can I help you today?", 
          masquerade
        );
        return;
      }

      // –ï—Å–ª–∏ –Ω–µ—Ç —Ç–µ–∫—Å—Ç–∞, –Ω–æ –µ—Å—Ç—å –≤–ª–æ–∂–µ–Ω–∏—è
      if (!content && attachments) {
        content = "Please describe this";
      }

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂
      const activeShapeId = this.shaperHandler.getActiveShape(message.channel);
      let shapeUsername;
      
      if (activeShapeId && this.availableShapes[activeShapeId]) {
        shapeUsername = this.availableShapes[activeShapeId];
      } else {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—ã–π –¥–æ—Å—Ç—É–ø–Ω—ã–π Shape –∫–∞–∫ default
        const firstShapeId = Object.keys(this.availableShapes)[0];
        shapeUsername = this.availableShapes[firstShapeId];
      }

      // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫ API
      const apiMessages = this.prepareAPIMessages(content, attachments);

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –∫ Shapes API
      const response = await this.shapes.chat.completions.create({
        model: `shapesinc/${shapeUsername}`,
        messages: apiMessages,
        temperature: 0.7,
        max_tokens: 1000
      });

      const aiResponse = response.choices[0].message.content;

      // –ü–æ–ª—É—á–∞–µ–º –º–∞—Å–∫–∞—Ä–∞–¥ –¥–ª—è –æ—Ç–≤–µ—Ç–∞
      const masquerade = await this.shaperHandler.getActiveMasquerade(message.channel);

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
      await this.messageManager.sendMessage(message.channel, aiResponse, masquerade, message._id);

    } catch (error) {
      console.error('Error processing message:', error.message);
      
      const masquerade = await this.shaperHandler.getActiveMasquerade(message.channel);
      await this.messageManager.sendMessage(
        message.channel, 
        "Sorry, I encountered an error while processing your request.", 
        masquerade
      );
    }
  }

  // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è API
  prepareAPIMessages(content, attachments) {
    if (attachments) {
      const contentArray = [{ type: "text", text: content || "Please describe this" }];
      
      if (attachments.image) {
        contentArray.push({
          type: "image_url",
          image_url: { url: attachments.image }
        });
      }
      
      if (attachments.audio) {
        contentArray.push({
          type: "audio_url",
          audio_url: { url: attachments.audio }
        });
      }
      
      return [{ role: "user", content: contentArray }];
    } else {
      return [{ role: "user", content: content }];
    }
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–ª–æ–∂–µ–Ω–∏–π
  processAttachments(attachments) {
    if (!attachments || attachments.length === 0) return null;
    
    const result = {};
    const REVOLT_SERVER_URL = process.env.REVOLT_SERVER_URL || 'https://autumn.revolt.chat';
    
    for (const attachment of attachments) {
      let url = '';
      
      if (attachment.url) {
        url = attachment.url;
      } else if (attachment._id || attachment.id) {
        const attachmentId = attachment._id || attachment.id;
        url = `${REVOLT_SERVER_URL}/attachments/${attachmentId}`;
      }
      
      if (url && !url.startsWith('http')) {
        url = `https://${url}`;
      }
      
      if (!url) continue;
      
      const contentType = attachment.content_type || '';
      if (contentType.startsWith('image/') || url.match(/\.(jpeg|jpg|gif|png|webp)$/i)) {
        result.image = url;
      } else if (contentType.startsWith('audio/') || url.match(/\.(mp3|wav|ogg|m4a)$/i)) {
        result.audio = url;
      }
    }
    
    return Object.keys(result).length > 0 ? result : null;
  }
}

module.exports = MessageHandler;